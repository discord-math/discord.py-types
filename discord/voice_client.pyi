import asyncio
import socket
from .gateway import *
from . import abc
from .channel import StageChannel, VoiceChannel
from .client import Client
from .guild import Guild
from .opus import Encoder
from .player import AudioSource
from .types.voice import GuildVoiceState as GuildVoiceStatePayload, SupportedModes, VoiceServerUpdate as VoiceServerUpdatePayload
from .user import ClientUser
from typing import Any, Callable, List, Optional, Tuple, Union

VocalGuildChannel = Union[VoiceChannel, StageChannel]

class VoiceProtocol:
    client: Client
    channel: abc.Connectable
    def __init__(self, client: Client, channel: abc.Connectable) -> None: ...
    async def on_voice_state_update(self, data: GuildVoiceStatePayload) -> None: ...
    async def on_voice_server_update(self, data: VoiceServerUpdatePayload) -> None: ...
    async def connect(self, *, timeout: float, reconnect: bool, self_deaf: bool = ..., self_mute: bool = ...) -> None: ...
    async def disconnect(self, *, force: bool) -> None: ...
    def cleanup(self) -> None: ...

class VoiceClient(VoiceProtocol):
    channel: VocalGuildChannel
    endpoint_ip: str
    voice_port: int
    ip: str
    port: int
    secret_key: List[int]
    ssrc: int
    token: str
    server_id: int
    socket: socket.socket
    loop: asyncio.AbstractEventLoop
    mode: str
    sequence: int
    timestamp: int
    timeout: int
    encoder: Encoder
    ws: DiscordVoiceWebSocket
    def __init__(self, client: Client, channel: abc.Connectable) -> None: ...
    warn_nacl: bool
    supported_modes: Tuple[SupportedModes, ...]
    @property
    def guild(self) -> Guild: ...
    @property
    def user(self) -> ClientUser: ...
    def checked_add(self, attr: str, value: int, limit: int) -> None: ...
    session_id: str
    async def on_voice_state_update(self, data: GuildVoiceStatePayload) -> None: ...
    endpoint: str
    async def on_voice_server_update(self, data: VoiceServerUpdatePayload) -> None: ...
    async def voice_connect(self, self_deaf: bool = ..., self_mute: bool = ...) -> None: ...
    async def voice_disconnect(self) -> None: ...
    def prepare_handshake(self) -> None: ...
    def finish_handshake(self) -> None: ...
    async def connect_websocket(self) -> DiscordVoiceWebSocket: ...
    async def connect(self, *, reconnect: bool, timeout: float, self_deaf: bool = ..., self_mute: bool = ...) -> None: ...
    async def potential_reconnect(self) -> bool: ...
    @property
    def latency(self) -> float: ...
    @property
    def average_latency(self) -> float: ...
    async def poll_voice_ws(self, reconnect: bool) -> None: ...
    async def disconnect(self, *, force: bool = ...) -> None: ...
    async def move_to(self, channel: Optional[abc.Snowflake]) -> None: ...
    def is_connected(self) -> bool: ...
    def play(self, source: AudioSource, *, after: Optional[Callable[[Optional[Exception]], Any]] = ...) -> None: ...
    def is_playing(self) -> bool: ...
    def is_paused(self) -> bool: ...
    def stop(self) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    @property
    def source(self) -> Optional[AudioSource]: ...
    @source.setter
    def source(self, value: AudioSource) -> None: ...
    def send_audio_packet(self, data: bytes, *, encode: bool = ...) -> None: ...
