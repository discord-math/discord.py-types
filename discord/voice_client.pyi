import asyncio
import socket
from .abc import Connectable, Snowflake
from .client import Client
from .gateway import DiscordVoiceWebSocket
from .guild import Guild
from .opus import Encoder
from .player import AudioSource
from .types.voice import GuildVoiceState as GuildVoiceStatePayload, SupportedModes, VoiceServerUpdate as VoiceServerUpdatePayload
from .user import ClientUser
from typing import Any, Callable, List, Optional, Tuple

class VoiceProtocol:
    client: Client
    channel: Connectable
    def __init__(self, client: Client, channel: Connectable) -> None: ...
    async def on_voice_state_update(self, data: GuildVoiceStatePayload) -> None: ...
    async def on_voice_server_update(self, data: VoiceServerUpdatePayload) -> None: ...
    async def connect(self, *, timeout: float, reconnect: bool) -> None: ...
    async def disconnect(self, *, force: bool) -> None: ...
    def cleanup(self) -> None: ...

class VoiceClient(VoiceProtocol):
    endpoint_ip: str
    voice_port: int
    secret_key: List[int]
    ssrc: int
    token: str
    socket: socket.socket
    loop: asyncio.AbstractEventLoop
    mode: str
    sequence: int
    timestamp: int
    timeout: int
    encoder: Encoder
    ws: DiscordVoiceWebSocket
    def __init__(self, client: Client, channel: Connectable) -> None: ...
    warn_nacl: bool
    supported_modes: Tuple[SupportedModes, ...]
    @property
    def guild(self) -> Optional[Guild]: ...
    @property
    def user(self) -> ClientUser: ...
    session_id: str
    channel: Connectable
    async def on_voice_state_update(self, data: GuildVoiceStatePayload) -> None: ...
    server_id: int
    endpoint: str
    async def on_voice_server_update(self, data: VoiceServerUpdatePayload) -> None: ...
    async def voice_connect(self) -> None: ...
    async def voice_disconnect(self) -> None: ...
    def prepare_handshake(self) -> None: ...
    def finish_handshake(self) -> None: ...
    async def connect_websocket(self) -> DiscordVoiceWebSocket: ...
    async def connect(self, *, reconnect: bool, timeout: float) -> None: ...
    async def potential_reconnect(self) -> bool: ...
    @property
    def latency(self) -> float: ...
    @property
    def average_latency(self) -> float: ...
    async def poll_voice_ws(self, reconnect: bool) -> None: ...
    async def disconnect(self, *, force: bool = ...) -> None: ...
    async def move_to(self, channel: Snowflake) -> None: ...
    def is_connected(self) -> bool: ...
    def play(self, source: AudioSource, *, after: Callable[[Optional[Exception]], Any] = ...) -> None: ...
    def is_playing(self) -> bool: ...
    def is_paused(self) -> bool: ...
    def stop(self) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    @property
    def source(self) -> Optional[AudioSource]: ...
    @source.setter
    def source(self, value: AudioSource) -> None: ...
    def send_audio_packet(self, data: bytes, *, encode: bool = ...) -> None: ...
