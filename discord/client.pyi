import asyncio
import datetime
from .abc import GuildChannel, PrivateChannel, Snowflake, SnowflakeTime
from .activity import ActivityTypes, BaseActivity
from .appinfo import AppInfo
from .channel import DMChannel, GroupChannel, PartialMessageable, TextChannel
from .emoji import Emoji
from .enums import ChannelType, Status, VoiceRegion
from .flags import ApplicationFlags, Intents
from .gateway import DiscordWebSocket
from .guild import Guild
from .integrations import Integration
from .interactions import Interaction
from .invite import Invite
from .iterators import GuildIterator
from .member import Member, VoiceState
from .mentions import AllowedMentions
from .message import Message
from .raw_models import RawBulkMessageDeleteEvent, RawIntegrationDeleteEvent, RawMessageDeleteEvent, RawMessageUpdateEvent, RawReactionActionEvent, RawReactionClearEmojiEvent, RawReactionClearEvent
from .reaction import Reaction
from .role import Role
from .stage_instance import StageInstance
from .sticker import GuildSticker, StandardSticker, StickerPack
from .template import Template
from .threads import Thread, ThreadMember
from .ui.view import View
from .user import ClientUser, User
from .voice_client import VoiceProtocol
from .webhook import Webhook
from .widget import Widget
from typing import Any, Callable, Coroutine, Generator, List, Literal, Optional, Sequence, Tuple, TypeVar, Union, overload

Coro = TypeVar('Coro', bound=Callable[..., Coroutine[Any, Any, Any]])

class Client:
    ws: DiscordWebSocket
    loop: asyncio.AbstractEventLoop
    shard_id: Optional[int]
    shard_count: Optional[int]
    http: Any
    def __init__(self, *, loop: Optional[asyncio.AbstractEventLoop] = ..., **options: Any): ...
    @property
    def latency(self) -> float: ...
    def is_ws_ratelimited(self) -> bool: ...
    @property
    def user(self) -> Optional[ClientUser]: ...
    @property
    def guilds(self) -> List[Guild]: ...
    @property
    def emojis(self) -> List[Emoji]: ...
    @property
    def stickers(self) -> List[GuildSticker]: ...
    @property
    def cached_messages(self) -> Sequence[Message]: ...
    @property
    def private_channels(self) -> List[PrivateChannel]: ...
    @property
    def voice_clients(self) -> List[VoiceProtocol]: ...
    @property
    def application_id(self) -> Optional[int]: ...
    @property
    def application_flags(self) -> ApplicationFlags: ...
    def is_ready(self) -> bool: ...
    def dispatch(self, event: str, *args: Any, **kwargs: Any) -> None: ...
    async def on_error(self, event_method: str, *args: Any, **kwargs: Any) -> None: ...
    async def before_identify_hook(self, shard_id: Optional[int], *, initial: bool = ...) -> None: ...
    async def login(self, token: str) -> None: ...
    async def connect(self, *, reconnect: bool = ...) -> None: ...
    async def close(self) -> None: ...
    def clear(self) -> None: ...
    async def start(self, token: str, *, reconnect: bool = ...) -> None: ...
    def run(self, *args: Any, **kwargs: Any) -> None: ...
    def is_closed(self) -> bool: ...
    @property
    def activity(self) -> Optional[ActivityTypes]: ...
    @activity.setter
    def activity(self, value: Optional[ActivityTypes]) -> None: ...
    @property
    def status(self) -> Status: ...
    @status.setter
    def status(self, value: Status) -> None: ...
    @property
    def allowed_mentions(self) -> Optional[AllowedMentions]: ...
    @allowed_mentions.setter
    def allowed_mentions(self, value: Optional[AllowedMentions]) -> None: ...
    @property
    def intents(self) -> Intents: ...
    @property
    def users(self) -> List[User]: ...
    def get_channel(self, id: int) -> Optional[Union[GuildChannel, Thread, PrivateChannel]]: ...
    def get_partial_messageable(self, id: int, *, type: Optional[ChannelType] = ...) -> PartialMessageable: ...
    def get_stage_instance(self, id: int) -> Optional[StageInstance]: ...
    def get_guild(self, id: int) -> Optional[Guild]: ...
    def get_user(self, id: int) -> Optional[User]: ...
    def get_emoji(self, id: int) -> Optional[Emoji]: ...
    def get_sticker(self, id: int) -> Optional[GuildSticker]: ...
    def get_all_channels(self) -> Generator[GuildChannel, None, None]: ...
    def get_all_members(self) -> Generator[Member, None, None]: ...
    async def wait_until_ready(self) -> None: ...
    @overload
    def wait_for(self, event: Literal['connect'], *, check: Optional[Callable[[], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[None]: ...
    @overload
    def wait_for(self, event: Literal['shard_connect'], *, check: Optional[Callable[[int], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[int]: ...
    @overload
    def wait_for(self, event: Literal['disconnect'], *, check: Optional[Callable[[], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[None]: ...
    @overload
    def wait_for(self, event: Literal['shard_disconnect'], *, check: Optional[Callable[[int], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[int]: ...
    @overload
    def wait_for(self, event: Literal['ready'], *, check: Optional[Callable[[], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[None]: ...
    @overload
    def wait_for(self, event: Literal['shard_ready'], *, check: Optional[Callable[[int], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[int]: ...
    @overload
    def wait_for(self, event: Literal['resumed'], *, check: Optional[Callable[[], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[None]: ...
    @overload
    def wait_for(self, event: Literal['shard_resumed'], *, check: Optional[Callable[[int], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[int]: ...
    @overload
    def wait_for(self, event: Literal['error'], *, check: Optional[Callable[..., bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Any, ...]]: ...
    @overload
    def wait_for(self, event: Literal['socket_event_type'], *, check: Optional[Callable[[str], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[str]: ...
    @overload
    def wait_for(self, event: Literal['socket_raw_receive'], *, check: Optional[Callable[[str], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[str]: ...
    @overload
    def wait_for(self, event: Literal['socket_raw_send'], *, check: Optional[Callable[[Union[bytes, str]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Union[bytes, str]]: ...
    @overload
    def wait_for(self, event: Literal['typing'], *, check: Optional[Callable[[Union[TextChannel, GroupChannel, DMChannel], Union[User, Member], datetime.datetime], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Union[TextChannel, GroupChannel, DMChannel], Union[User, Member], datetime.datetime]]: ...
    @overload
    def wait_for(self, event: Literal['message'], *, check: Optional[Callable[[Message], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Message]: ...
    @overload
    def wait_for(self, event: Literal['message_delete'], *, check: Optional[Callable[[Message], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Message]: ...
    @overload
    def wait_for(self, event: Literal['bulk_message_delete'], *, check: Optional[Callable[[List[Message]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[List[Message]]: ...
    @overload
    def wait_for(self, event: Literal['raw_message_delete'], *, check: Optional[Callable[[RawMessageDeleteEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawMessageDeleteEvent]: ...
    @overload
    def wait_for(self, event: Literal['raw_bulk_message_delete'], *, check: Optional[Callable[[RawBulkMessageDeleteEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawBulkMessageDeleteEvent]: ...
    @overload
    def wait_for(self, event: Literal['message_edit'], *, check: Optional[Callable[[Message, Message], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Message, Message]]: ...
    @overload
    def wait_for(self, event: Literal['raw_message_edit'], *, check: Optional[Callable[[RawMessageUpdateEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawMessageUpdateEvent]: ...
    @overload
    def wait_for(self, event: Literal['reaction_add'], *, check: Optional[Callable[[Reaction, Union[Member, User]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Reaction, Union[Member, User]]]: ...
    @overload
    def wait_for(self, event: Literal['raw_reaction_add'], *, check: Optional[Callable[[RawReactionActionEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawReactionActionEvent]: ...
    @overload
    def wait_for(self, event: Literal['reaction_remove'], *, check: Optional[Callable[[Reaction, Union[Member, User]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Reaction, Union[Member, User]]]: ...
    @overload
    def wait_for(self, event: Literal['raw_reaction_remove'], *, check: Optional[Callable[[RawReactionActionEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawReactionActionEvent]: ...
    @overload
    def wait_for(self, event: Literal['reaction_clear'], *, check: Optional[Callable[[Message, List[Reaction]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Message, List[Reaction]]]: ...
    @overload
    def wait_for(self, event: Literal['raw_reaction_clear'], *, check: Optional[Callable[[RawReactionClearEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawReactionClearEvent]: ...
    @overload
    def wait_for(self, event: Literal['reaction_clear_emoji'], *, check: Optional[Callable[[Reaction], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Reaction]: ...
    @overload
    def wait_for(self, event: Literal['raw_reaction_clear_emoji'], *, check: Optional[Callable[[RawReactionClearEmojiEvent], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[RawReactionClearEmojiEvent]: ...
    @overload
    def wait_for(self, event: Literal['interaction'], *, check: Optional[Callable[[Interaction], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Interaction]: ...
    @overload
    def wait_for(self, event: Literal['private_channel_update'], *, check: Optional[Callable[[GroupChannel, GroupChannel], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[GroupChannel, GroupChannel]]: ...
    @overload
    def wait_for(self, event: Literal['private_channel_pins_update'], *, check: Optional[Callable[[PrivateChannel, Optional[datetime.datetime]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[PrivateChannel, Optional[datetime.datetime]]]: ...
    @overload
    def wait_for(self, event: Literal['guild_channel_delete'], *, check: Optional[Callable[[GuildChannel], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[GuildChannel]: ...
    @overload
    def wait_for(self, event: Literal['guild_channel_create'], *, check: Optional[Callable[[GuildChannel], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[GuildChannel]: ...
    @overload
    def wait_for(self, event: Literal['guild_channel_update'], *, check: Optional[Callable[[GuildChannel, GuildChannel], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[GuildChannel, GuildChannel]]: ...
    @overload
    def wait_for(self, event: Literal['guild_channel_pins_update'], *, check: Optional[Callable[[Union[GuildChannel, Thread], Optional[datetime.datetime]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Union[GuildChannel, Thread], Optional[datetime.datetime]]]: ...
    @overload
    def wait_for(self, event: Literal['thread_join'], *, check: Optional[Callable[[Thread], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Thread]: ...
    @overload
    def wait_for(self, event: Literal['thread_remove'], *, check: Optional[Callable[[Thread], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Thread]: ...
    @overload
    def wait_for(self, event: Literal['thread_delete'], *, check: Optional[Callable[[Thread], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Thread]: ...
    @overload
    def wait_for(self, event: Literal['thread_member_join'], *, check: Optional[Callable[[ThreadMember], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[ThreadMember]: ...
    @overload
    def wait_for(self, event: Literal['thread_member_remove'], *, check: Optional[Callable[[ThreadMember], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[ThreadMember]: ...
    @overload
    def wait_for(self, event: Literal['thread_member_update'], *, check: Optional[Callable[[Thread, Thread], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Thread, Thread]]: ...
    @overload
    def wait_for(self, event: Literal['guild_integrations_update'], *, check: Optional[Callable[[Guild], bool]], timeout: Optional[float] = ...) -> asyncio.Future[Guild]: ...
    @overload
    def wait_for(self, event: Literal['integration_create'], *, check: Optional[Callable[[Integration], bool]], timeout: Optional[float] = ...) -> asyncio.Future[Integration]: ...
    @overload
    def wait_for(self, event: Literal['integration_update'], *, check: Optional[Callable[[Integration], bool]], timeout: Optional[float] = ...) -> asyncio.Future[Integration]: ...
    @overload
    def wait_for(self, event: Literal['integration_delete'], *, check: Optional[Callable[[RawIntegrationDeleteEvent], bool]], timeout: Optional[float] = ...) -> asyncio.Future[RawIntegrationDeleteEvent]: ...
    @overload
    def wait_for(self, event: Literal['webhooks_update'], *, check: Optional[Callable[[GuildChannel], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[GuildChannel]: ...
    @overload
    def wait_for(self, event: Literal['member_join'], *, check: Optional[Callable[[Member], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Member]: ...
    @overload
    def wait_for(self, event: Literal['member_remove'], *, check: Optional[Callable[[Member], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Member]: ...
    @overload
    def wait_for(self, event: Literal['member_update'], *, check: Optional[Callable[[Member, Member], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Member, Member]]: ...
    @overload
    def wait_for(self, event: Literal['presence_update'], *, check: Optional[Callable[[Member, Member], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Member, Member]]: ...
    @overload
    def wait_for(self, event: Literal['user_update'], *, check: Optional[Callable[[User, User], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[User, User]]: ...
    @overload
    def wait_for(self, event: Literal['guild_join'], *, check: Optional[Callable[[Guild], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Guild]: ...
    @overload
    def wait_for(self, event: Literal['guild_remove'], *, check: Optional[Callable[[Guild], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Guild]: ...
    @overload
    def wait_for(self, event: Literal['guild_update'], *, check: Optional[Callable[[Guild, Guild], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Guild, Guild]]: ...
    @overload
    def wait_for(self, event: Literal['guild_role_create'], *, check: Optional[Callable[[Role], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Role]: ...
    @overload
    def wait_for(self, event: Literal['guild_role_delete'], *, check: Optional[Callable[[Role], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Role]: ...
    @overload
    def wait_for(self, event: Literal['guild_role_update'], *, check: Optional[Callable[[Role, Role], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Role, Role]]: ...
    @overload
    def wait_for(self, event: Literal['guild_emojis_update'], *, check: Optional[Callable[[Guild, Sequence[Emoji], Sequence[Emoji]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Guild, Sequence[Emoji], Sequence[Emoji]]]: ...
    @overload
    def wait_for(self, event: Literal['guild_stickers_update'], *, check: Optional[Callable[[Guild, Sequence[GuildSticker], Sequence[GuildSticker]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Guild, Sequence[GuildSticker], Sequence[GuildSticker]]]: ...
    @overload
    def wait_for(self, event: Literal['guild_available'], *, check: Optional[Callable[[Guild], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Guild]: ...
    @overload
    def wait_for(self, event: Literal['guild_unavailable'], *, check: Optional[Callable[[Guild], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Guild]: ...
    @overload
    def wait_for(self, event: Literal['voice_state_update'], *, check: Optional[Callable[[Member, VoiceState, VoiceState], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Member, VoiceState, VoiceState]]: ...
    @overload
    def wait_for(self, event: Literal['stage_instance_create'], *, check: Optional[Callable[[StageInstance], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[StageInstance]: ...
    @overload
    def wait_for(self, event: Literal['stage_instance_delete'], *, check: Optional[Callable[[StageInstance], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[StageInstance]: ...
    @overload
    def wait_for(self, event: Literal['stage_instance_update'], *, check: Optional[Callable[[StageInstance, StageInstance], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[StageInstance, StageInstance]]: ...
    @overload
    def wait_for(self, event: Literal['member_ban'], *, check: Optional[Callable[[Guild, Union[Member, User]], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Guild, Union[Member, User]]]: ...
    @overload
    def wait_for(self, event: Literal['member_unban'], *, check: Optional[Callable[[Guild, User], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[Guild, User]]: ...
    @overload
    def wait_for(self, event: Literal['invite_create'], *, check: Optional[Callable[[Invite], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Invite]: ...
    @overload
    def wait_for(self, event: Literal['invite_delete'], *, check: Optional[Callable[[Invite], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Invite]: ...
    @overload
    def wait_for(self, event: Literal['group_join'], *, check: Optional[Callable[[GroupChannel, User], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[GroupChannel, User]]: ...
    @overload
    def wait_for(self, event: Literal['group_remove'], *, check: Optional[Callable[[GroupChannel, User], bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Tuple[GroupChannel, User]]: ...
    @overload
    def wait_for(self, event: str, *, check: Optional[Callable[..., bool]] = ..., timeout: Optional[float] = ...) -> asyncio.Future[Any]: ...
    def event(self, coro: Coro) -> Coro: ...
    async def change_presence(self, *, activity: Optional[BaseActivity] = ..., status: Optional[Status] = ...) -> None: ...
    def fetch_guilds(self, *, limit: Optional[int] = ..., before: SnowflakeTime = ..., after: SnowflakeTime = ...) -> GuildIterator: ...
    async def fetch_template(self, code: Union[Template, str]) -> Template: ...
    async def fetch_guild(self, guild_id: int) -> Guild: ...
    async def create_guild(self, name: str, *, region: Union[VoiceRegion, str] = ..., icon: bytes = ..., code: str = ...) -> Guild: ...
    async def fetch_stage_instance(self, channel_id: int) -> StageInstance: ...
    async def fetch_invite(self, url: Union[Invite, str], *, with_counts: bool = ..., with_expiration: bool = ...) -> Invite: ...
    async def delete_invite(self, invite: Union[Invite, str]) -> None: ...
    async def fetch_widget(self, guild_id: int) -> Widget: ...
    async def application_info(self) -> AppInfo: ...
    async def fetch_user(self, user_id: int) -> User: ...
    async def fetch_channel(self, channel_id: int) -> Union[GuildChannel, PrivateChannel, Thread]: ...
    async def fetch_webhook(self, webhook_id: int) -> Webhook: ...
    async def fetch_sticker(self, sticker_id: int) -> Union[StandardSticker, GuildSticker]: ...
    async def fetch_premium_sticker_packs(self) -> List[StickerPack]: ...
    async def create_dm(self, user: Snowflake) -> DMChannel: ...
    def add_view(self, view: View, *, message_id: Optional[int] = ...) -> None: ...
    @property
    def persistent_views(self) -> Sequence[View]: ...
