import aiohttp
import asyncio
import threading
from .activity import BaseActivity
from .client import Client
from .enums import SpeakingState
from .voice_client import VoiceClient
from typing import Any, Callable, Coroutine, Deque, Dict, List, NamedTuple, Optional, Type, TypeVar

class ReconnectWebSocket(Exception):
    shard_id: Optional[int]
    resume: bool
    op: str
    def __init__(self, shard_id: Optional[int], *, resume: bool = ...) -> None: ...

class WebSocketClosure(Exception): ...

class EventListener(NamedTuple):
    predicate: Callable[[Dict[str, Any]], bool]
    event: str
    result: Optional[Callable[[Dict[str, Any]], Any]]
    future: asyncio.Future[Any]

class GatewayRatelimiter:
    max: int
    remaining: int
    window: float
    per: float
    lock: asyncio.Lock
    shard_id: Optional[int]
    def __init__(self, count: int = ..., per: float = ...) -> None: ...
    def is_ratelimited(self) -> bool: ...
    def get_delay(self) -> float: ...
    async def block(self) -> None: ...

class KeepAliveHandler(threading.Thread):
    ws: DiscordWebSocket
    interval: Optional[float]
    daemon: bool
    shard_id: Optional[int]
    msg: str
    block_msg: str
    behind_msg: str
    latency: float
    heartbeat_timeout: float
    def __init__(self, *args: Any, ws: DiscordWebSocket, interval: Optional[float] = ..., shard_id: Optional[int] = ..., **kwargs: Any) -> None: ...
    def run(self) -> None: ...
    def get_payload(self) -> Dict[str, Any]: ...
    def stop(self) -> None: ...
    def tick(self) -> None: ...
    def ack(self) -> None: ...

class VoiceKeepAliveHandler(KeepAliveHandler):
    recent_ack_latencies: Deque[float]
    msg: str
    block_msg: str
    behind_msg: str
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def get_payload(self) -> Dict[str, Any]: ...
    latency: float
    def ack(self) -> None: ...

class DiscordClientWebSocketResponse(aiohttp.ClientWebSocketResponse):
    async def close(self, *, code: int = ..., message: bytes = ...) -> bool: ...
DWS = TypeVar('DWS', bound='DiscordWebSocket')

class DiscordWebSocket:
    token: Optional[str]
    call_hooks: Callable[..., Any]
    shard_id: Optional[int]
    shard_count: Optional[int]
    gateway: str
    DISPATCH: int
    HEARTBEAT: int
    IDENTIFY: int
    PRESENCE: int
    VOICE_STATE: int
    VOICE_PING: int
    RESUME: int
    RECONNECT: int
    REQUEST_MEMBERS: int
    INVALIDATE_SESSION: int
    HELLO: int
    HEARTBEAT_ACK: int
    GUILD_SYNC: int
    socket: aiohttp.ClientWebSocketResponse
    loop: asyncio.AbstractEventLoop
    thread_id: int
    session_id: Optional[str]
    sequence: Optional[int]
    def __init__(self, socket: aiohttp.ClientWebSocketResponse, *, loop: asyncio.AbstractEventLoop) -> None: ...
    @property
    def open(self) -> bool: ...
    def is_ratelimited(self) -> bool: ...
    def debug_log_receive(self, data: Dict[str, Any]) -> None: ...
    def log_receive(self, _: Dict[str, Any]) -> None: ...
    @classmethod
    async def from_client(cls: Type[DWS], client: Client, *, initial: bool = ..., gateway: Optional[str] = ..., shard_id: Optional[int] = ..., session: Optional[str] = ..., sequence: Optional[int] = ..., resume: bool = ...) -> DWS: ...
    def wait_for(self, event: str, predicate: Callable[[Dict[str, Any]], bool], result: Optional[Callable[[Dict[str, Any]], Any]] = ...) -> asyncio.Future[Any]: ...
    async def identify(self) -> None: ...
    async def resume(self) -> None: ...
    async def received_message(self, msg: Any) -> None: ...
    @property
    def latency(self) -> float: ...
    async def poll_event(self) -> None: ...
    async def debug_send(self, data: str) -> None: ...
    async def send(self, data: str) -> None: ...
    async def send_as_json(self, data: Any) -> None: ...
    async def send_heartbeat(self, data: Any) -> None: ...
    async def change_presence(self, *, activity: Optional[BaseActivity] = ..., status: Optional[str] = ..., since: float = ...) -> None: ...
    async def request_chunks(self, guild_id: int, query: Optional[str] = ..., *, limit: int, user_ids: Optional[List[int]] = ..., presences: bool = ..., nonce: Optional[str] = ...) -> None: ...
    async def voice_state(self, guild_id: int, channel_id: Optional[int], self_mute: bool = ..., self_deaf: bool = ...) -> None: ...
    async def close(self, code: int = ...) -> None: ...
DVWS = TypeVar('DVWS', bound='DiscordVoiceWebSocket')

class DiscordVoiceWebSocket:
    thread_id: int
    gateway: str
    IDENTIFY: int
    SELECT_PROTOCOL: int
    READY: int
    HEARTBEAT: int
    SESSION_DESCRIPTION: int
    SPEAKING: int
    HEARTBEAT_ACK: int
    RESUME: int
    HELLO: int
    RESUMED: int
    CLIENT_CONNECT: int
    CLIENT_DISCONNECT: int
    ws: aiohttp.ClientWebSocketResponse
    loop: asyncio.AbstractEventLoop
    secret_key: Optional[str]
    def __init__(self, socket: aiohttp.ClientWebSocketResponse, loop: asyncio.AbstractEventLoop, *, hook: Optional[Callable[..., Coroutine[Any, Any, Any]]] = ...) -> None: ...
    async def send_as_json(self, data: Any) -> None: ...
    async def send_heartbeat(self, data: Any) -> None: ...
    async def resume(self) -> None: ...
    async def identify(self) -> None: ...
    @classmethod
    async def from_client(cls: Type[DVWS], client: VoiceClient, *, resume: bool = ..., hook: Optional[Callable[..., Coroutine[Any, Any, Any]]] = ...) -> DVWS: ...
    async def select_protocol(self, ip: str, port: int, mode: int) -> None: ...
    async def client_connect(self) -> None: ...
    async def speak(self, state: SpeakingState = ...) -> None: ...
    async def received_message(self, msg: Dict[str, Any]) -> None: ...
    async def initial_connection(self, data: Dict[str, Any]) -> None: ...
    @property
    def latency(self) -> float: ...
    @property
    def average_latency(self) -> float: ...
    async def load_secret_key(self, data: Dict[str, Any]) -> None: ...
    async def poll_event(self) -> None: ...
    async def close(self, code: int = ...) -> None: ...
