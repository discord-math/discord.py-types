import aiohttp
import threading
from .client import Client
from typing import Any, NamedTuple, Optional

class ReconnectWebSocket(Exception):
    shard_id: Any
    resume: bool
    op: str
    def __init__(self, shard_id: Any, *, resume: bool = ...) -> None: ...

class KeepAliveHandler(threading.Thread):
    ws: Any
    interval: Any
    daemon: bool
    shard_id: Optional[int]
    msg: str
    block_msg: str
    behind_msg: str
    latency: float
    heartbeat_timeout: Any
    def run(self) -> None: ...
    def get_payload(self) -> Any: ...
    def stop(self) -> None: ...
    def tick(self) -> None: ...
    def ack(self) -> None: ...

class VoiceKeepAliveHandler(KeepAliveHandler):
    msg: str
    block_msg: str
    behind_msg: str
    def get_payload(self) -> Any: ...
    latency: Any
    def ack(self) -> None: ...

class DiscordWebSocket:
    DISPATCH: int
    HEARTBEAT: int
    IDENTIFY: int
    PRESENCE: int
    VOICE_STATE: int
    VOICE_PING: int
    RESUME: int
    RECONNECT: int
    REQUEST_MEMBERS: int
    INVALIDATE_SESSION: int
    HELLO: int
    HEARTBEAT_ACK: int
    GUILD_SYNC: int
    socket: Any
    loop: Any
    thread_id: Any
    session_id: Any
    sequence: Any
    @property
    def open(self) -> bool: ...
    def is_ratelimited(self) -> bool: ...
    def debug_log_receive(self, data: Any) -> None: ...
    def log_receive(self, _: Any) -> None: ...
    @classmethod
    async def from_client(cls, client: Client, *, initial: bool = ..., gateway: Any | None = ..., shard_id: Any | None = ..., session: Any | None = ..., sequence: Any | None = ..., resume: bool = ...) -> DiscordWebSocket: ...
    def wait_for(self, event: Any, predicate: Any, result: Any | None = ...) -> Any: ...
    async def identify(self) -> None: ...
    async def resume(self) -> None: ...
    async def received_message(self, msg: Any) -> None: ...
    @property
    def latency(self) -> float: ...
    async def poll_event(self) -> None: ...
    async def debug_send(self, data: Any) -> None: ...
    async def send(self, data: Any) -> None: ...
    async def send_as_json(self, data: Any) -> None: ...
    async def send_heartbeat(self, data: Any) -> None: ...
    async def change_presence(self, *, activity: Any | None = ..., status: Any | None = ..., since: float = ...) -> None: ...
    async def request_chunks(self, guild_id: int, query: Any | None = ..., *, limit: Any, user_ids: Any | None = ..., presences: bool = ..., nonce: Any | None = ...) -> None: ...
    async def voice_state(self, guild_id: int, channel_id: int, self_mute: bool = ..., self_deaf: bool = ...) -> None: ...
    async def close(self, code: int = ...) -> None: ...

class DiscordVoiceWebSocket:
    IDENTIFY: int
    SELECT_PROTOCOL: int
    READY: int
    HEARTBEAT: int
    SESSION_DESCRIPTION: int
    SPEAKING: int
    HEARTBEAT_ACK: int
    RESUME: int
    HELLO: int
    RESUMED: int
    CLIENT_CONNECT: int
    CLIENT_DISCONNECT: int
    ws: Any
    loop: Any
    secret_key: Any
    async def send_as_json(self, data: Any) -> None: ...
    send_heartbeat: Any
    async def resume(self) -> None: ...
    async def identify(self) -> None: ...
    @classmethod
    async def from_client(cls, client: Client, *, resume: bool = ..., hook: Any | None = ...) -> DiscordVoiceWebSocket: ...
    async def select_protocol(self, ip: Any, port: Any, mode: Any) -> None: ...
    async def client_connect(self) -> None: ...
    async def speak(self, state: Any = ...) -> None: ...
    async def received_message(self, msg: Any) -> None: ...
    async def initial_connection(self, data: Any) -> None: ...
    @property
    def latency(self) -> float: ...
    @property
    def average_latency(self) -> float: ...
    async def load_secret_key(self, data: Any) -> None: ...
    async def poll_event(self) -> None: ...
    async def close(self, code: int = ...) -> None: ...
