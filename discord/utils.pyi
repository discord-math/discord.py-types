import abc
import array
import datetime
from .abc import Snowflake
from .permissions import Permissions
from typing import Any, AsyncIterable, AsyncIterator, Awaitable, Callable, Coroutine, Generic, Iterable, Iterator, Literal, List, Mapping, NamedTuple, Optional, Sequence, Type, TypeVar, Union, overload

MISSING: Any

_SnowflakeListBase = array.array[int]
T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
Coro = Coroutine[Any, Any, T]
MaybeAwaitable = Union[T, Awaitable[T]]

class CachedSlotProperty(Generic[T, T_co]):
    name: str
    function: Callable[[T], T_co]
    __doc__: Optional[str]
    def __init__(self, name: str, function: Callable[[T], T_co]) -> None: ...
    @overload
    def __get__(self, instance: None, owner: Type[T]) -> CachedSlotProperty[T, T_co]: ...
    @overload
    def __get__(self, instance: T, owner: Type[T]) -> T_co: ...

class classproperty:
    fget: Callable[[Any], T_co]
    def __init__(self, fget: Callable[[Any], T_co]) -> None: ...
    def __get__(self, instance: Optional[Any], owner: Type[Any]) -> T_co: ...
    def __set__(self, instance: Optional[Any], value: Any) -> None: ...

class SequenceProxy(Sequence[T_co]):
    def __init__(self, proxied: Sequence[T_co]) -> None: ...
    def __getitem__(self, idx: int) -> T_co: ... # type: ignore
    def __len__(self) -> int: ...
    def __contains__(self, item: Any) -> bool: ...
    def __iter__(self) -> Iterator[T_co]: ...
    def __reversed__(self) -> Iterator[T_co]: ...
    def index(self, value: Any, *args: Any, **kwargs: Any) -> int: ...
    def count(self, value: Any) -> int: ...

def oauth_url(client_id: Union[int, str], *, permissions: Permissions = ..., guild: Snowflake = ..., redirect_uri: str = ..., scopes: Iterable[str] = ..., disable_guild_select: bool = ...) -> str: ...
def snowflake_time(id: int) -> datetime.datetime: ...
def time_snowflake(dt: datetime.datetime, high: bool = ...) -> int: ...
@overload
def find(predicate: Callable[[T], Any], iterable: Iterable[T]) -> Optional[T]: ...
@overload
def find(predicate: Callable[[T], Any], iterable: AsyncIterable[T]) -> Coro[Optional[T]]: ...
@overload
def get(iterable: Iterable[T], **attrs: Any) -> Optional[T]: ...
@overload
def get(iterable: AsyncIterable[T], **attrs: Any) -> Coro[Optional[T]]: ...
async def sleep_until(when: datetime.datetime, result: Optional[T] = ...) -> Optional[T]: ...
def utcnow() -> datetime.datetime: ...

SL = TypeVar('SL', bound='SnowflakeList')

class SnowflakeList(_SnowflakeListBase):
    def __init__(self, data: Iterable[int], *, is_sorted: bool = ...) -> None: ...
    def __new__(cls: Type[SL], data: Iterable[int], *, is_sorted: bool = ...) -> SL: ...
    def add(self, element: int) -> None: ...
    def get(self, element: int) -> Optional[int]: ...
    def has(self, element: int) -> bool: ...

class ResolvedInvite(NamedTuple):
    code: str
    event: Optional[int]

def remove_markdown(text: str, *, ignore_links: bool = ...) -> str: ...
def escape_markdown(text: str, *, as_needed: bool = ..., ignore_links: bool = ...) -> str: ...
def escape_mentions(text: str) -> str: ...
@overload
def as_chunks(iterator: Iterable[T], max_size: int) -> Iterator[List[T]]: ...
@overload
def as_chunks(iterator: AsyncIterable[T], max_size: int) -> AsyncIterator[List[T]]: ...

TimestampStyle = Literal['f', 'F', 'd', 'D', 't', 'T', 'R']

def format_dt(dt: datetime.datetime, style: Optional[TimestampStyle] = ...) -> str: ...
