import datetime
import io
import os
from .abc import GuildChannel, MessageableChannel, PartialMessageableChannel, Snowflake
from .components import Component
from .embeds import Embed
from .emoji import Emoji
from .enums import MessageType
from .file import File
from .flags import MessageFlags
from .guild import Guild
from .member import Member
from .mentions import AllowedMentions
from .mixins import Hashable
from .partial_emoji import PartialEmoji
from .reaction import Reaction
from .role import Role
from .state import ConnectionState
from .sticker import StickerItem
from .threads import Thread
from .types.threads import ThreadArchiveDuration
from .types.message import MessageActivity as MessageActivityPayload, MessageApplication as MessageApplicationPayload
from .ui.view import View
from .user import User
from typing import Any, List, Optional, Type, TypeVar, Union, overload

MR = TypeVar('MR', bound='MessageReference')
EmojiInputType = Union[Emoji, PartialEmoji, str]

class Attachment(Hashable):
    id: int
    size: int
    height: Optional[int]
    width: Optional[int]
    filename: str
    url: str
    proxy_url: str
    content_type: Optional[str]
    def is_spoiler(self) -> bool: ...
    async def save(self, fp: Union[io.BufferedIOBase, os.PathLike[str], os.PathLike[bytes]], *, seek_begin: bool = ..., use_cached: bool = ...) -> int: ...
    async def read(self, *, use_cached: bool = ...) -> bytes: ...
    async def to_file(self, *, use_cached: bool = ..., spoiler: bool = ...) -> File: ...

class DeletedReferencedMessage:
    def __init__(self, parent: MessageReference) -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def channel_id(self) -> int: ...
    @property
    def guild_id(self) -> Optional[int]: ...

class MessageReference:
    resolved: Optional[Union[Message, DeletedReferencedMessage]]
    message_id: Optional[int]
    channel_id: int
    guild_id: int
    fail_if_not_exists: bool
    def __init__(self, message_id: int, channel_id: int, *, guild_id: Optional[int] = ..., fail_if_not_exists: bool = ...) -> None: ...
    @classmethod
    def from_message(cls: Type[MR], message: Message, *, fail_if_not_exists: bool = ...) -> MR: ...
    @property
    def cached_message(self) -> Optional[Message]: ...
    @property
    def jump_url(self) -> str: ...

class Message(Hashable):
    guild: Optional[Guild]
    reference: Optional[MessageReference]
    mentions: List[Union[User, Member]]
    author: Union[User, Member]
    role_mentions: List[Role]
    id: int
    webhook_id: Optional[int]
    reactions: List[Reaction]
    attachments: List[Attachment]
    embeds: List[Embed]
    application: Optional[MessageApplicationPayload]
    activity: Optional[MessageActivityPayload]
    channel: MessageableChannel
    type: MessageType
    pinned: bool
    flags: MessageFlags
    mention_everyone: bool
    tts: bool
    content: str
    nonce: Optional[Union[int, str]]
    stickers: List[StickerItem]
    components: List[Component]
    def raw_mentions(self) -> List[int]: ...
    def raw_channel_mentions(self) -> List[int]: ...
    def raw_role_mentions(self) -> List[int]: ...
    def channel_mentions(self) -> List[GuildChannel]: ...
    def clean_content(self) -> str: ...
    @property
    def created_at(self) -> datetime.datetime: ...
    @property
    def edited_at(self) -> Optional[datetime.datetime]: ...
    @property
    def jump_url(self) -> str: ...
    def is_system(self) -> bool: ...
    def system_content(self) -> str: ...
    async def delete(self, *, delay: Optional[float] = ...) -> None: ...
    @overload
    async def edit(self, *, content: Optional[str] = ..., embed: Optional[Embed] = ..., attachments: List[Attachment] = ..., suppress: bool = ..., delete_after: Optional[float] = ..., allowed_mentions: Optional[AllowedMentions] = ..., view: Optional[View] = ...) -> Message: ...
    @overload
    async def edit(self, *, content: Optional[str] = ..., embeds: List[Embed] = ..., attachments: List[Attachment] = ..., suppress: bool = ..., delete_after: Optional[float] = ..., allowed_mentions: Optional[AllowedMentions] = ..., view: Optional[View] = ...) -> Message: ...
    async def publish(self) -> None: ...
    async def pin(self, *, reason: Optional[str] = ...) -> None: ...
    async def unpin(self, *, reason: Optional[str] = ...) -> None: ...
    async def add_reaction(self, emoji: EmojiInputType) -> None: ...
    async def remove_reaction(self, emoji: Union[EmojiInputType, Reaction], member: Snowflake) -> None: ...
    async def clear_reaction(self, emoji: Union[EmojiInputType, Reaction]) -> None: ...
    async def clear_reactions(self) -> None: ...
    async def create_thread(self, name: str, *, auto_archive_duration: ThreadArchiveDuration = ...) -> Thread: ...
    async def reply(self, content: Optional[str] = ..., **kwargs: Any) -> Message: ...
    def to_reference(self, *, fail_if_not_exists: bool = ...) -> MessageReference: ...

class PartialMessage(Hashable):
    jump_url: str
    async def delete(self, *, delay: Optional[float] = ...) -> None: ...
    async def publish(self) -> None: ...
    async def pin(self, *, reason: Optional[str] = ...) -> None: ...
    async def unpin(self, *, reason: Optional[str] = ...) -> None: ...
    async def add_reaction(self, emoji: EmojiInputType) -> None: ...
    async def remove_reaction(self, emoji: Union[EmojiInputType, Reaction], member: Snowflake) -> None: ...
    async def clear_reaction(self, emoji: Union[EmojiInputType, Reaction]) -> None: ...
    async def clear_reactions(self) -> None: ...
    async def reply(self, content: Optional[str] = ..., **kwargs: Any) -> Message: ...
    def to_reference(self, *, fail_if_not_exists: bool = ...) -> MessageReference: ...
    channel: PartialMessageableChannel
    id: int
    def __init__(self, channel: PartialMessageableChannel, id: int) -> None: ...
    pinned: None
    @property
    def created_at(self) -> datetime.datetime: ...
    def guild(self) -> Optional[Guild]: ...
    async def fetch(self) -> Message: ...
    async def edit(self, **fields: Any) -> Optional[Message]: ...
