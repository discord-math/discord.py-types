import io
import threading
from .voice_client import VoiceClient
from typing import Any, Callable, Generic, IO, Optional, Tuple, Type, TypeVar, Union

AT = TypeVar('AT', bound='AudioSource')

class AudioSource:
    def read(self) -> bytes: ...
    def is_opus(self) -> bool: ...
    def cleanup(self) -> None: ...
    def __del__(self) -> None: ...

class PCMAudio(AudioSource):
    stream: io.BufferedIOBase
    def __init__(self, stream: io.BufferedIOBase) -> None: ...
    def read(self) -> bytes: ...

class FFmpegAudio(AudioSource):
    def __init__(self, source: Union[str, io.BufferedIOBase], *, executable: str = ..., args: Any, **subprocess_kwargs: Any) -> None: ...
    def cleanup(self) -> None: ...

class FFmpegPCMAudio(FFmpegAudio):
    def __init__(self, source: Union[str, io.BufferedIOBase], *, executable: str = ..., pipe: bool = ..., stderr: Optional[IO[str]] = ..., before_options: Optional[str] = ..., options: Optional[str] = ...) -> None: ...
    def read(self) -> bytes: ...
    def is_opus(self) -> bool: ...

FOA = TypeVar('FOA', bound='FFmpegOpusAudio')

class FFmpegOpusAudio(FFmpegAudio):
    def __init__(self, source: Union[str, io.BufferedIOBase], *, bitrate: Optional[int] = ..., codec: Optional[str] = ..., executable: str = ..., pipe: bool = ..., stderr: Optional[IO[bytes]] = ..., before_options: Optional[str] = ..., options: Optional[str] = ...) -> None: ...
    @classmethod
    async def from_probe(cls: Type[FOA], source: str, *, method: Optional[Union[str, Callable[[str, str], Tuple[Optional[str], Optional[int]]]]] = ..., **kwargs: Any) -> FOA: ...
    @classmethod
    async def probe(cls, source: str, *, method: Optional[Union[str, Callable[[str, str], Tuple[Optional[str], Optional[int]]]]] = ..., executable: Optional[str] = ...) -> Tuple[Optional[str], Optional[int]]: ...
    def read(self) -> bytes: ...
    def is_opus(self) -> bool: ...

class PCMVolumeTransformer(AudioSource, Generic[AT]):
    original: AT
    def __init__(self, original: AT, volume: float = ...) -> None: ...
    @property
    def volume(self) -> float: ...
    @volume.setter
    def volume(self, value: float) -> None: ...
    def cleanup(self) -> None: ...
    def read(self) -> bytes: ...

class AudioPlayer(threading.Thread):
    DELAY: float
    daemon: bool
    source: AudioSource
    client: VoiceClient
    after: Optional[Callable[[Optional[Exception]], Any]]
    def __init__(self, source: AudioSource, client: VoiceClient, *, after: Optional[Callable[[Optional[Exception]], Any]] = ...) -> None: ...
    def run(self) -> None: ...
    def stop(self) -> None: ...
    def pause(self, *, update_speaking: bool = ...) -> None: ...
    loops: int
    def resume(self, *, update_speaking: bool = ...) -> None: ...
    def is_playing(self) -> bool: ...
    def is_paused(self) -> bool: ...
