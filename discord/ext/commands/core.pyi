from .errors import *
from ._types import BotT, Check, CogT, ContextT, Coro, Error, Hook, P, _BaseCommand
from .context import Context
from .cooldowns import BucketType, Cooldown
from .parameters import Parameter
from discord.message import Message
from typing import Any, Callable, Concatenate, Dict, Generator, Generic, List, Optional, Set, Tuple, Type, TypeVar, Union, overload

T = TypeVar('T')
CommandT = TypeVar('CommandT', bound='Command[Any, Any, Any, Any]')
GroupT = TypeVar('GroupT', bound='Group[Any, Any, Any, Any]')

class Command(_BaseCommand, Generic[CogT, ContextT, P, T]):
    __original_kwargs__: Dict[str, Any]
    def __new__(cls: Type[CommandT], *args: Any, **kwargs: Any) -> CommandT: ...
    name: str
    enabled: bool
    help: Optional[str]
    brief: Optional[str]
    usage: Optional[str]
    rest_is_raw: bool
    aliases: Union[List[str], Tuple[str]]
    extras: Dict[str, Any]
    description: str
    hidden: bool
    checks: List[Check[ContextT]]
    require_var_positional: bool
    ignore_extra: bool
    cooldown_after_parsing: bool
    parent: Optional[GroupMixin[Any, Any]]
    def __init__(self, func: Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]], **kwargs: Any) -> None: ...
    @property
    def cog(self) -> CogT: ...
    @cog.setter
    def cog(self, value: CogT) -> None: ...
    @property
    def callback(self) -> Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]]: ...
    @callback.setter
    def callback(self, function: Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]]) -> None: ...
    module: str
    params: Dict[str, Parameter]
    def add_check(self, func: Check[ContextT]) -> None: ...
    def remove_check(self, func: Check[ContextT]) -> None: ...
    def update(self, **kwargs: Any) -> None: ...
    async def __call__(self, context: Context[BotT], *args: P.args, **kwargs: P.kwargs) -> T: ...
    def copy(self: CommandT) -> CommandT: ...
    async def dispatch_error(self, ctx: Context[BotT], error: CommandError) -> None: ...
    async def transform(self, ctx: Context[BotT], param: Parameter) -> Any: ...
    @property
    def clean_params(self) -> Dict[str, Parameter]: ...
    @property
    def cooldown(self) -> Optional[Cooldown]: ...
    @property
    def full_parent_name(self) -> str: ...
    @property
    def parents(self) -> List[Group[Any, Any, ..., Any]]: ...
    @property
    def root_parent(self) -> Optional[Group[Any, Any, ..., Any]]: ...
    @property
    def qualified_name(self) -> str: ...
    async def call_before_hooks(self, ctx: Context[BotT]) -> None: ...
    async def call_after_hooks(self, ctx: Context[BotT]) -> None: ...
    async def prepare(self, ctx: Context[BotT]) -> None: ...
    def is_on_cooldown(self, ctx: Context[BotT]) -> bool: ...
    def reset_cooldown(self, ctx: Context[BotT]) -> None: ...
    def get_cooldown_retry_after(self, ctx: Context[BotT]) -> float: ...
    async def invoke(self, ctx: ContextT) -> None: ...
    async def reinvoke(self, ctx: ContextT, *, call_hooks: bool = ...) -> None: ...
    on_error: Error[Any, Any]
    def error(self, coro: Error[CogT, ContextT]) -> Error[CogT, ContextT]: ...
    def has_error_handler(self) -> bool: ...
    def before_invoke(self, coro: Hook[CogT, ContextT]) -> Hook[CogT, ContextT]: ...
    def after_invoke(self, coro: Hook[CogT, ContextT]) -> Hook[CogT, ContextT]: ...
    @property
    def cog_name(self) -> Optional[str]: ...
    @property
    def short_doc(self) -> str: ...
    @property
    def signature(self) -> str: ...
    async def can_run(self, ctx: Context[BotT]) -> bool: ...

class GroupMixin(Generic[CogT, ContextT]):
    all_commands: Dict[str, Command[CogT, ContextT, ..., Any]]
    case_insensitive: bool
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def commands(self) -> Set[Command[CogT, ContextT, ..., Any]]: ...
    def recursively_remove_all_commands(self) -> None: ...
    def add_command(self, command: Command[CogT, ContextT, ..., Any]) -> None: ...
    def remove_command(self, name: str) -> Optional[Command[CogT, ContextT, ..., Any]]: ...
    def walk_commands(self) -> Generator[Command[CogT, ContextT, ..., Any], None, None]: ...
    def get_command(self, name: str) -> Optional[Command[CogT, ContextT, ..., Any]]: ...
    @overload
    def command(self, name: str = ..., *args: Any, **kwargs: Any) -> Callable[[Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]]], Command[CogT, ContextT, P, T]]: ...
    @overload
    def command(self, name: str = ..., cls: Type[CommandT] = ..., *args: Any, **kwargs: Any) -> Callable[[Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]]], CommandT]: ... # type: ignore
    @overload
    def group(self, name: str = ..., *args: Any, **kwargs: Any) -> Callable[[Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]]], Group[CogT, ContextT, P, T]]: ...
    @overload
    def group(self, name: str = ..., cls: Type[GroupT] = ..., *args: Any, **kwargs: Any) -> Callable[[Union[Callable[Concatenate[CogT, ContextT, P], Coro[T]], Callable[Concatenate[ContextT, P], Coro[T]]]], GroupT]: ... # type: ignore

class Group(GroupMixin[CogT, ContextT], Command[CogT, ContextT, P, T]): # type: ignore
    invoke_without_command: bool
    def __init__(self, *args: Any, **attrs: Any) -> None: ...
    def copy(self: GroupT) -> GroupT: ...
    async def invoke(self, ctx: ContextT) -> None: ...
    async def reinvoke(self, ctx: ContextT, *, call_hooks: bool = ...) -> None: ...

class _CommandDecorator:
    @overload
    def __call__(self, func: Callable[Concatenate[CogT, ContextT, P], Coro[T]]) -> Command[CogT, ContextT, P, T]: ...
    @overload
    def __call__(self, func: Callable[Concatenate[ContextT, P], Coro[T]]) -> Command[None, ContextT, P, T]: ...

class _GroupDecorator:
    @overload
    def __call__(self, func: Callable[Concatenate[CogT, ContextT, P], Coro[T]]) -> Group[CogT, ContextT, P, T]: ...
    @overload
    def __call__(self, func: Callable[Concatenate[ContextT, P], Coro[T]]) -> Group[None, ContextT, P, T]: ...


@overload
def command(name: str = ..., **attrs: Any) -> _CommandDecorator: ...
@overload
def command(name: str = ..., cls: Type[CommandT] = ..., **attrs: Any) -> Callable[[Union[Callable[Concatenate[ContextT, P], Coro[Any]], Callable[Concatenate[CogT, ContextT, P], Coro[Any]]]], CommandT]: ...
@overload
def group(name: str = ..., **attrs: Any) -> _GroupDecorator: ...
@overload
def group(name: str = ..., cls: Type[GroupT] = ..., **attrs: Any) -> Callable[[Union[Callable[Concatenate[CogT, ContextT, P], Coro[Any]], Callable[Concatenate[ContextT, P], Coro[Any]]]], GroupT]: ...
def check(predicate: Check[ContextT]) -> Callable[[T], T]: ...
def check_any(*checks: Check[ContextT]) -> Callable[[T], T]: ...
def has_role(item: Union[int, str]) -> Callable[[T], T]: ...
def has_any_role(*items: Union[int, str]) -> Callable[[T], T]: ...
def bot_has_role(item: int) -> Callable[[T], T]: ...
def bot_has_any_role(*items: int) -> Callable[[T], T]: ...
def has_permissions(**perms: bool) -> Callable[[T], T]: ...
def bot_has_permissions(**perms: bool) -> Callable[[T], T]: ...
def has_guild_permissions(**perms: bool) -> Callable[[T], T]: ...
def bot_has_guild_permissions(**perms: bool) -> Callable[[T], T]: ...
def dm_only() -> Callable[[T], T]: ...
def guild_only() -> Callable[[T], T]: ...
def is_owner() -> Callable[[T], T]: ...
def is_nsfw() -> Callable[[T], T]: ...
def cooldown(rate: int, per: float, type: Union[BucketType, Callable[[Message], Any]] = ...) -> Callable[[T], T]: ...
def dynamic_cooldown(cooldown: Union[BucketType, Callable[[Message], Any]], type: BucketType = ...) -> Callable[[T], T]: ...
def max_concurrency(number: int, per: BucketType = ..., *, wait: bool = ...) -> Callable[[T], T]: ...
def before_invoke(coro: Hook[CogT, ContextT]) -> Callable[[T], T]: ...
def after_invoke(coro: Hook[CogT, ContextT]) -> Callable[[T], T]: ...
