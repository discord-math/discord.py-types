import datetime
import discord.abc
from .abc import Snowflake, SnowflakeTime
from .asset import Asset
from .embeds import Embed
from .enums import ChannelType, PrivacyLevel, VideoQualityMode
from .file import File
from .guild import Guild, GuildChannel as GuildChannelType
from .member import Member, VoiceState
from .mentions import AllowedMentions
from .message import Message, PartialMessage
from .mixins import Hashable
from .permissions import PermissionOverwrite, Permissions
from .role import Role
from .scheduled_event import ScheduledEvent
from .stage_instance import StageInstance
from .state import ConnectionState
from .sticker import GuildSticker, StickerItem
from .threads import Thread
from .types.channel import CategoryChannel as CategoryChannelPayload, DMChannel as DMChannelPayload, ForumChannel as ForumChannelPayload, GroupDMChannel as GroupChannelPayload, NewsChannel as NewsChannelPayload, StageChannel as StageChannelPayload, TextChannel as TextChannelPayload, VoiceChannel as VoiceChannelPayload
from .types.threads import ThreadArchiveDuration
from .ui.view import View
from .user import BaseUser, ClientUser, User
from .webhook import Webhook
from typing import Any, AsyncIterator, Callable, Dict, Iterable, List, Literal, Mapping, Optional, Sequence, Union, overload

class TextChannel(discord.abc.Messageable, discord.abc.GuildChannel, Hashable):
    name: str
    id: int
    guild: Guild
    topic: Optional[str]
    nsfw: bool
    category_id: Optional[int]
    position: int
    slowmode_delay: int
    last_message_id: Optional[int]
    default_auto_archive_duration: ThreadArchiveDuration
    def __init__(self, *, state: ConnectionState, guild: Guild, data: Union[TextChannelPayload, NewsChannelPayload]) -> None: ...
    @property
    def type(self) -> Literal[ChannelType.text, ChannelType.news]: ... # type: ignore
    def permissions_for(self, obj: Union[Member, Role]) -> Permissions: ...
    @property
    def members(self) -> List[Member]: ...
    @property
    def threads(self) -> List[Thread]: ...
    def is_nsfw(self) -> bool: ...
    def is_news(self) -> bool: ...
    @property
    def last_message(self) -> Optional[Message]: ...
    @overload
    async def edit(self) -> Optional[TextChannel]: ... # type: ignore
    @overload
    async def edit(self, *, position: int, reason: Optional[str] = ...) -> None: ... # type: ignore
    @overload
    async def edit(self, *, reason: Optional[str] = ..., name: str = ..., topic: str = ..., position: int = ..., nsfw: bool = ..., sync_permissions: bool = ..., category: Optional[CategoryChannel] = ..., slowmode_delay: int = ..., default_auto_archive_duration: ThreadArchiveDuration = ..., type: ChannelType = ..., overwrites: Mapping[Union[Role, Member, Snowflake], PermissionOverwrite] = ...) -> TextChannel: ...
    async def clone(self, *, name: Optional[str] = ..., reason: Optional[str] = ...) -> TextChannel: ...
    async def delete_messages(self, messages: Iterable[Snowflake], *, reason: Optional[str] = ...) -> None: ...
    async def purge(self, *, limit: Optional[int] = ..., check: Callable[[Message], bool] = ..., before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ..., around: Optional[SnowflakeTime] = ..., oldest_first: Optional[bool] = ..., bulk: bool = ..., reason: Optional[str] = ...) -> List[Message]: ...
    async def webhooks(self) -> List[Webhook]: ...
    async def create_webhook(self, *, name: str, avatar: Optional[bytes] = ..., reason: Optional[str] = ...) -> Webhook: ...
    async def follow(self, *, destination: TextChannel, reason: Optional[str] = ...) -> Webhook: ...
    def get_partial_message(self, message_id: int) -> PartialMessage: ...
    def get_thread(self, thread_id: int) -> Optional[Thread]: ...
    async def create_thread(self, *, name: str, message: Optional[Snowflake] = ..., auto_archive_duration: ThreadArchiveDuration = ..., type: Optional[ChannelType] = ..., reason: Optional[str] = ..., invitable: bool = ..., slowmode_delay: Optional[int] = ...) -> Thread: ...
    async def archived_threads(self, *, private: bool = ..., joined: bool = ..., limit: Optional[int] = ..., before: Optional[Union[Snowflake, datetime.datetime]] = ...) -> AsyncIterator[Thread]: ...

class VocalGuildChannel(discord.abc.Connectable, discord.abc.GuildChannel, Hashable):
    name: str
    id: int
    guild: Guild
    nsfw: bool
    bitrate: int
    user_limit: int
    position: int
    category_id: Optional[int]
    rtc_region: Optional[str]
    video_quality_mode: VideoQualityMode
    last_message_id: Optional[int]
    def __init__(self, *, state: ConnectionState, guild: Guild, data: Union[VoiceChannelPayload, StageChannelPayload]) -> None: ...
    def is_nsfw(self) -> bool: ...
    @property
    def members(self) -> List[Member]: ...
    @property
    def voice_states(self) -> Dict[int, VoiceState]: ...
    @property
    def scheduled_events(self) -> List[ScheduledEvent]: ...
    def permissions_for(self, obj: Union[Member, Role]) -> Permissions: ...

class VoiceChannel(discord.abc.Messageable, VocalGuildChannel):
    @property
    def type(self) -> Literal[ChannelType.voice]: ... # type: ignore
    @property
    def last_message(self) -> Optional[Message]: ...
    def get_partial_message(self, message_id: int) -> PartialMessage: ...
    async def delete_messages(self, messages: Iterable[Snowflake], *, reason: Optional[str] = ...) -> None: ...
    async def purge(self, *, limit: Optional[int] = ..., check: Callable[[Message], bool] = ..., before: Optional[SnowflakeTime] = ..., after: Optional[SnowflakeTime] = ..., around: Optional[SnowflakeTime] = ..., oldest_first: Optional[bool] = ..., bulk: bool = ..., reason: Optional[str] = ...) -> List[Message]: ...
    async def webhooks(self) -> List[Webhook]: ...
    async def create_webhook(self, *, name: str, avatar: Optional[bytes] = ..., reason: Optional[str] = ...) -> Webhook: ...
    async def clone(self, *, name: Optional[str] = ..., reason: Optional[str] = ...) -> VoiceChannel: ...
    @overload
    async def edit(self) -> None: ... # type: ignore
    @overload
    async def edit(self, *, position: int, reason: Optional[str] = ...) -> None: ... # type: ignore
    @overload
    async def edit(self, *, name: str = ..., nsfw: bool = ..., bitrate: int = ..., user_limit: int = ..., position: int = ..., sync_permissions: int = ..., category: Optional[CategoryChannel] = ..., overwrites: Mapping[Union[Role, Member], PermissionOverwrite] = ..., rtc_region: Optional[str] = ..., video_quality_mode: VideoQualityMode = ..., reason: Optional[str] = ...) -> VoiceChannel: ...

class StageChannel(VocalGuildChannel):
    topic: Optional[str]
    @property
    def requesting_to_speak(self) -> List[Member]: ...
    @property
    def speakers(self) -> List[Member]: ...
    @property
    def listeners(self) -> List[Member]: ...
    @property
    def moderators(self) -> List[Member]: ...
    @property
    def type(self) -> Literal[ChannelType.stage_voice]: ... # type: ignore
    async def clone(self, *, name: Optional[str] = ..., reason: Optional[str] = ...) -> StageChannel: ...
    @property
    def instance(self) -> Optional[StageInstance]: ...
    async def create_instance(self, *, topic: str, privacy_level: PrivacyLevel = ..., reason: Optional[str] = ...) -> StageInstance: ...
    async def fetch_instance(self) -> StageInstance: ...
    @overload
    async def edit(self) -> None: ... # type: ignore
    @overload
    async def edit(self, *, position: int, reason: Optional[str] = ...) -> None: ... # type: ignore
    @overload
    async def edit(self, *, name: str = ..., nsfw: bool = ..., position: int = ..., sync_permissions: int = ..., category: Optional[CategoryChannel] = ..., overwrites: Mapping[Union[Role, Member], PermissionOverwrite] = ..., rtc_region: Optional[str] = ..., video_quality_mode: VideoQualityMode = ..., reason: Optional[str] = ...) -> StageChannel: ...

class CategoryChannel(discord.abc.GuildChannel, Hashable):
    name: str
    id: int
    guild: Guild
    nsfw: bool
    position: int
    category_id: Optional[int]
    def __init__(self, *, state: ConnectionState, guild: Guild, data: CategoryChannelPayload) -> None: ...
    @property
    def type(self) -> Literal[ChannelType.category]: ... # type: ignore
    def is_nsfw(self) -> bool: ...
    async def clone(self, *, name: Optional[str] = ..., reason: Optional[str] = ...) -> CategoryChannel: ...
    @overload
    async def edit(self) -> None: ... # type: ignore
    @overload
    async def edit(self, *, position: int, reason: Optional[str] = ...) -> None: ... # type: ignore
    @overload
    async def edit(self, *, name: str = ..., position: int = ..., nsfw: bool = ..., overwrites: Mapping[Union[Role, Member], PermissionOverwrite] = ..., reason: Optional[str] = ...) -> CategoryChannel: ...
    async def move(self, **kwargs: Any) -> None: ...
    @property
    def channels(self) -> List[GuildChannelType]: ...
    @property
    def text_channels(self) -> List[TextChannel]: ...
    @property
    def voice_channels(self) -> List[VoiceChannel]: ...
    @property
    def stage_channels(self) -> List[StageChannel]: ...
    async def create_text_channel(self, name: str, **options: Any) -> TextChannel: ...
    async def create_voice_channel(self, name: str, **options: Any) -> VoiceChannel: ...
    async def create_stage_channel(self, name: str, **options: Any) -> StageChannel: ...

class ForumChannel(discord.abc.GuildChannel, Hashable):
    name: str
    id: int
    guild: Guild
    topic: Optional[str]
    nsfw: bool
    category_id: Optional[int]
    position: int
    slowmode_delay: int
    last_message_id: Optional[int]
    default_auto_archive_duration: ThreadArchiveDuration
    def __init__(self, *, state: ConnectionState, guild: Guild, data: ForumChannelPayload) -> None: ...
    @property
    def type(self) -> Literal[ChannelType.forum]: ... # type: ignore
    def permissions_for(self, obj: Union[Member, Role]) -> Permissions: ...
    @property
    def threads(self) -> List[Thread]: ...
    def is_nsfw(self) -> bool: ...
    async def clone(self, *, name: Optional[str] = ..., reason: Optional[str] = ...) -> ForumChannel: ...
    @overload
    async def edit(self) -> None: ... # type: ignore
    @overload
    async def edit(self, *, position: int, reason: Optional[str] = ...) -> None: ... # type: ignore
    @overload
    async def edit(self, *, reason: Optional[str] = ..., name: str = ..., topic: str = ..., position: int = ..., nsfw: bool = ..., sync_permissions: bool = ..., category: Optional[CategoryChannel] = ..., slowmode_delay: int = ..., default_auto_archive_duration: ThreadArchiveDuration = ..., type: ChannelType = ..., overwrites: Mapping[Union[Role, Member, Snowflake], PermissionOverwrite] = ...) -> ForumChannel: ...
    async def create_thread(self, *, name: str, auto_archive_duration: ThreadArchiveDuration = ..., slowmode_delay: Optional[int] = ..., content: Optional[str] = ..., tts: bool = ..., embed: Embed = ..., embeds: Sequence[Embed] = ..., file: File = ..., files: Sequence[File] = ..., stickers: Sequence[Union[GuildSticker, StickerItem]] = ..., allowed_mentions: AllowedMentions = ..., mention_author: bool = ..., view: View = ..., suppress_embeds: bool = ..., reason: Optional[str] = ...) -> Thread: ...

class DMChannel(discord.abc.Messageable, Hashable):
    id: int
    recipient: Optional[User]
    me: ClientUser
    def __init__(self, *, me: ClientUser, state: ConnectionState, data: DMChannelPayload) -> None: ...
    @property
    def type(self) -> Literal[ChannelType.private]: ...
    @property
    def jump_url(self) -> str: ...
    @property
    def created_at(self) -> datetime.datetime: ...
    def permissions_for(self, obj: Any = ...) -> Permissions: ...
    def get_partial_message(self, message_id: int) -> PartialMessage: ...

class GroupChannel(discord.abc.Messageable, Hashable):
    id: int
    recipients: List[User]
    owner_id: Optional[int]
    owner: Optional[BaseUser]
    name: Optional[str]
    me: ClientUser
    def __init__(self, *, me: ClientUser, state: ConnectionState, data: GroupChannelPayload) -> None: ...
    @property
    def type(self) -> Literal[ChannelType.group]: ...
    @property
    def icon(self) -> Optional[Asset]: ...
    @property
    def created_at(self) -> datetime.datetime: ...
    @property
    def jump_url(self) -> str: ...
    def permissions_for(self, obj: Snowflake) -> Permissions: ...
    async def leave(self) -> None: ...

class PartialMessageable(discord.abc.Messageable, Hashable):
    id: int
    type: Optional[ChannelType]
    def __init__(self, state: ConnectionState, id: int, type: Optional[ChannelType] = ...) -> None: ...
    def get_partial_message(self, message_id: int) -> PartialMessage: ...
